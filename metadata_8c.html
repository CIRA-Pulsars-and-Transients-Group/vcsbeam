<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VCSBeam: metadata.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VCSBeam
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">metadata.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;mwalib.h&gt;</code><br />
<code>#include &quot;vcsbeam.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for metadata.c:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="metadata_8c__incl.svg" width="536" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7a572becfecd297d68a8b296b29cd0f8"><td class="memItemLeft" align="right" valign="top">vcsbeam_context *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a7a572becfecd297d68a8b296b29cd0f8">vmInit</a> (bool use_mpi)</td></tr>
<tr class="memdesc:a7a572becfecd297d68a8b296b29cd0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a VCSBeam context struct.  <a href="metadata_8c.html#a7a572becfecd297d68a8b296b29cd0f8">More...</a><br /></td></tr>
<tr class="separator:a7a572becfecd297d68a8b296b29cd0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091372039dcad27a96221fa22cd58d5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a091372039dcad27a96221fa22cd58d5e">vmBindObsData</a> (vcsbeam_context *vm, char *first_coarse_chan_str, int num_coarse_chans_to_process, int coarse_chan_idx_offset, char *first_gps_second_str, int num_gps_seconds_to_process, int gps_second_offset, char *datadir)</td></tr>
<tr class="memdesc:a091372039dcad27a96221fa22cd58d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a set of observation files to the VCSBeam context.  <a href="metadata_8c.html#a091372039dcad27a96221fa22cd58d5e">More...</a><br /></td></tr>
<tr class="separator:a091372039dcad27a96221fa22cd58d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d82fbfb82a80d86875463d9cc542486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a6d82fbfb82a80d86875463d9cc542486">vmBindCalibrationData</a> (vcsbeam_context *vm, char *caldir, int cal_type, bool use_bandpass, char *flags_file)</td></tr>
<tr class="memdesc:a6d82fbfb82a80d86875463d9cc542486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a calibration solution to the VCSBeam context.  <a href="metadata_8c.html#a6d82fbfb82a80d86875463d9cc542486">More...</a><br /></td></tr>
<tr class="separator:a6d82fbfb82a80d86875463d9cc542486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1824ef3922bf4cd94ba1d17d9b6789f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#aa1824ef3922bf4cd94ba1d17d9b6789f">vmReadCalibration</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:aa1824ef3922bf4cd94ba1d17d9b6789f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in a calibration solution.  <a href="metadata_8c.html#aa1824ef3922bf4cd94ba1d17d9b6789f">More...</a><br /></td></tr>
<tr class="separator:aa1824ef3922bf4cd94ba1d17d9b6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0a6247393ba2c9f493315c21005fcd"><td class="memItemLeft" align="right" valign="top">Antenna *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a6e0a6247393ba2c9f493315c21005fcd">find_antenna_by_name</a> (MetafitsMetadata *obs_metadata, char *tile_name)</td></tr>
<tr class="memdesc:a6e0a6247393ba2c9f493315c21005fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an antenna in an observation with a given name.  <a href="metadata_8c.html#a6e0a6247393ba2c9f493315c21005fcd">More...</a><br /></td></tr>
<tr class="separator:a6e0a6247393ba2c9f493315c21005fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8b4c5ae6f35a9e2992867e6ba2cbfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#aac8b4c5ae6f35a9e2992867e6ba2cbfe">destroy_vcsbeam_context</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:aac8b4c5ae6f35a9e2992867e6ba2cbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory associated with the VCSBeam context.  <a href="metadata_8c.html#aac8b4c5ae6f35a9e2992867e6ba2cbfe">More...</a><br /></td></tr>
<tr class="separator:aac8b4c5ae6f35a9e2992867e6ba2cbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab000c14b3b5a0101dc26391aa8c38c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#ab000c14b3b5a0101dc26391aa8c38c3d">vmSetOutputChannelisation</a> (vcsbeam_context *vm, bool out_fine, bool out_coarse)</td></tr>
<tr class="memdesc:ab000c14b3b5a0101dc26391aa8c38c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets flags governing whether the PFB and inverse PFB routines are run depending on the input and output channelisations.  <a href="metadata_8c.html#ab000c14b3b5a0101dc26391aa8c38c3d">More...</a><br /></td></tr>
<tr class="separator:ab000c14b3b5a0101dc26391aa8c38c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724190b8e83033d8ab2b2e520e7b05b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a724190b8e83033d8ab2b2e520e7b05b5">vmMallocVHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a724190b8e83033d8ab2b2e520e7b05b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the input voltages on the CPU.  <a href="metadata_8c.html#a724190b8e83033d8ab2b2e520e7b05b5">More...</a><br /></td></tr>
<tr class="separator:a724190b8e83033d8ab2b2e520e7b05b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8152b712ffd26aee6aede80c746231ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a8152b712ffd26aee6aede80c746231ac">vmMallocJVHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a8152b712ffd26aee6aede80c746231ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf J}{\bf v}\) on the CPU.  <a href="metadata_8c.html#a8152b712ffd26aee6aede80c746231ac">More...</a><br /></td></tr>
<tr class="separator:a8152b712ffd26aee6aede80c746231ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5f9e8e858b0534cfc164d1eebde98f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#aae5f9e8e858b0534cfc164d1eebde98f">vmMallocEHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:aae5f9e8e858b0534cfc164d1eebde98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf e}\) on the CPU.  <a href="metadata_8c.html#aae5f9e8e858b0534cfc164d1eebde98f">More...</a><br /></td></tr>
<tr class="separator:aae5f9e8e858b0534cfc164d1eebde98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31244370219af727e316abca277b4d98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a31244370219af727e316abca277b4d98">vmMallocSHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a31244370219af727e316abca277b4d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf S}\) on the CPU.  <a href="metadata_8c.html#a31244370219af727e316abca277b4d98">More...</a><br /></td></tr>
<tr class="separator:a31244370219af727e316abca277b4d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa524cc6f8c6bad8c8e2c76d2e4717de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#aa524cc6f8c6bad8c8e2c76d2e4717de5">vmMallocJHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:aa524cc6f8c6bad8c8e2c76d2e4717de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf J}\) on the CPU.  <a href="metadata_8c.html#aa524cc6f8c6bad8c8e2c76d2e4717de5">More...</a><br /></td></tr>
<tr class="separator:aa524cc6f8c6bad8c8e2c76d2e4717de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403313a0a88799c37b5424c922cc164c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a403313a0a88799c37b5424c922cc164c">vmMallocDHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a403313a0a88799c37b5424c922cc164c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf D}\) on the CPU.  <a href="metadata_8c.html#a403313a0a88799c37b5424c922cc164c">More...</a><br /></td></tr>
<tr class="separator:a403313a0a88799c37b5424c922cc164c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdefe77192dfcbdfb6c1a986cdce5f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#abdefe77192dfcbdfb6c1a986cdce5f5f">vmMallocPQIdxsHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:abdefe77192dfcbdfb6c1a986cdce5f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the polarisation indexes on the CPU.  <a href="metadata_8c.html#abdefe77192dfcbdfb6c1a986cdce5f5f">More...</a><br /></td></tr>
<tr class="separator:abdefe77192dfcbdfb6c1a986cdce5f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afb5e0fe27c01f9b23a3eabb7b37092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a3afb5e0fe27c01f9b23a3eabb7b37092">vmFreeVHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a3afb5e0fe27c01f9b23a3eabb7b37092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated for the input voltages on the CPU.  <a href="metadata_8c.html#a3afb5e0fe27c01f9b23a3eabb7b37092">More...</a><br /></td></tr>
<tr class="separator:a3afb5e0fe27c01f9b23a3eabb7b37092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c35892c7153ae8519bfc4daee2f8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#ad91c35892c7153ae8519bfc4daee2f8d">vmFreeJVHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:ad91c35892c7153ae8519bfc4daee2f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a8152b712ffd26aee6aede80c746231ac" title="Allocates memory for the quantity  on the CPU.">vmMallocJVHost()</a>.  <a href="metadata_8c.html#ad91c35892c7153ae8519bfc4daee2f8d">More...</a><br /></td></tr>
<tr class="separator:ad91c35892c7153ae8519bfc4daee2f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f60270f9a62f1a8ad55d550f9a00474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a7f60270f9a62f1a8ad55d550f9a00474">vmFreeEHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a7f60270f9a62f1a8ad55d550f9a00474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#aae5f9e8e858b0534cfc164d1eebde98f" title="Allocates memory for the quantity  on the CPU.">vmMallocEHost()</a>.  <a href="metadata_8c.html#a7f60270f9a62f1a8ad55d550f9a00474">More...</a><br /></td></tr>
<tr class="separator:a7f60270f9a62f1a8ad55d550f9a00474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f4b9a3f07109f98d2bc2bd2613e8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a36f4b9a3f07109f98d2bc2bd2613e8fd">vmFreeSHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a36f4b9a3f07109f98d2bc2bd2613e8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a31244370219af727e316abca277b4d98" title="Allocates memory for the quantity  on the CPU.">vmMallocSHost()</a>.  <a href="metadata_8c.html#a36f4b9a3f07109f98d2bc2bd2613e8fd">More...</a><br /></td></tr>
<tr class="separator:a36f4b9a3f07109f98d2bc2bd2613e8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8e5a587f033a1c98faf661d99f7685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a5b8e5a587f033a1c98faf661d99f7685">vmFreeJHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a5b8e5a587f033a1c98faf661d99f7685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#aa524cc6f8c6bad8c8e2c76d2e4717de5" title="Allocates memory for the quantity  on the CPU.">vmMallocJHost()</a>.  <a href="metadata_8c.html#a5b8e5a587f033a1c98faf661d99f7685">More...</a><br /></td></tr>
<tr class="separator:a5b8e5a587f033a1c98faf661d99f7685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae991cd418cfdccd1956ee2f81f42634a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#ae991cd418cfdccd1956ee2f81f42634a">vmFreeDHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:ae991cd418cfdccd1956ee2f81f42634a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a403313a0a88799c37b5424c922cc164c" title="Allocates memory for the quantity  on the CPU.">vmMallocDHost()</a>.  <a href="metadata_8c.html#ae991cd418cfdccd1956ee2f81f42634a">More...</a><br /></td></tr>
<tr class="separator:ae991cd418cfdccd1956ee2f81f42634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237de08cf463348bcb41139fd31c8271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a237de08cf463348bcb41139fd31c8271">vmFreePQIdxsHost</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a237de08cf463348bcb41139fd31c8271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#abdefe77192dfcbdfb6c1a986cdce5f5f" title="Allocates memory for the polarisation indexes on the CPU.">vmMallocPQIdxsHost()</a>.  <a href="metadata_8c.html#a237de08cf463348bcb41139fd31c8271">More...</a><br /></td></tr>
<tr class="separator:a237de08cf463348bcb41139fd31c8271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f21fd4f1390ced2d339afacdfe34fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a9f21fd4f1390ced2d339afacdfe34fdd">vmMallocVDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a9f21fd4f1390ced2d339afacdfe34fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the input voltages on the GPU.  <a href="metadata_8c.html#a9f21fd4f1390ced2d339afacdfe34fdd">More...</a><br /></td></tr>
<tr class="separator:a9f21fd4f1390ced2d339afacdfe34fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242cfb9b89103a9e46ac36e7cd2bf3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a242cfb9b89103a9e46ac36e7cd2bf3cc">vmMallocJVDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a242cfb9b89103a9e46ac36e7cd2bf3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantities \({\bf J}{\bf v}\) on the GPU.  <a href="metadata_8c.html#a242cfb9b89103a9e46ac36e7cd2bf3cc">More...</a><br /></td></tr>
<tr class="separator:a242cfb9b89103a9e46ac36e7cd2bf3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d01bd5ab04517acef1d876f3989a8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a5d01bd5ab04517acef1d876f3989a8cd">vmMallocEDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a5d01bd5ab04517acef1d876f3989a8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf e}\) on the GPU.  <a href="metadata_8c.html#a5d01bd5ab04517acef1d876f3989a8cd">More...</a><br /></td></tr>
<tr class="separator:a5d01bd5ab04517acef1d876f3989a8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50396fdf6698e705b50d7406d542b8ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a50396fdf6698e705b50d7406d542b8ff">vmMallocSDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a50396fdf6698e705b50d7406d542b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf S}\) on the GPU.  <a href="metadata_8c.html#a50396fdf6698e705b50d7406d542b8ff">More...</a><br /></td></tr>
<tr class="separator:a50396fdf6698e705b50d7406d542b8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bad3929557f04d2d1eb98fd554f303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a72bad3929557f04d2d1eb98fd554f303">vmMallocJDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a72bad3929557f04d2d1eb98fd554f303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf J}\) on the GPU.  <a href="metadata_8c.html#a72bad3929557f04d2d1eb98fd554f303">More...</a><br /></td></tr>
<tr class="separator:a72bad3929557f04d2d1eb98fd554f303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d07ad1565f6716220a662fc7ad08273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a0d07ad1565f6716220a662fc7ad08273">vmMallocDDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a0d07ad1565f6716220a662fc7ad08273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the quantity \({\bf D}\) on the GPU.  <a href="metadata_8c.html#a0d07ad1565f6716220a662fc7ad08273">More...</a><br /></td></tr>
<tr class="separator:a0d07ad1565f6716220a662fc7ad08273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e06ca450bcb8b3e922093a4c0b34c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a69e06ca450bcb8b3e922093a4c0b34c0">vmMallocPQIdxsDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a69e06ca450bcb8b3e922093a4c0b34c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the polarisation indexes on the GPU.  <a href="metadata_8c.html#a69e06ca450bcb8b3e922093a4c0b34c0">More...</a><br /></td></tr>
<tr class="separator:a69e06ca450bcb8b3e922093a4c0b34c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eed0fa043bb2638293788d612c9457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#ad1eed0fa043bb2638293788d612c9457">vmFreeVDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:ad1eed0fa043bb2638293788d612c9457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the GPU memory allocated with <a class="el" href="metadata_8c.html#a9f21fd4f1390ced2d339afacdfe34fdd" title="Allocates memory for the input voltages on the GPU.">vmMallocVDevice()</a>.  <a href="metadata_8c.html#ad1eed0fa043bb2638293788d612c9457">More...</a><br /></td></tr>
<tr class="separator:ad1eed0fa043bb2638293788d612c9457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29729f4b68c699f747386bdf39846237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a29729f4b68c699f747386bdf39846237">vmFreeJVDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a29729f4b68c699f747386bdf39846237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a242cfb9b89103a9e46ac36e7cd2bf3cc" title="Allocates memory for the quantities  on the GPU.">vmMallocJVDevice()</a>.  <a href="metadata_8c.html#a29729f4b68c699f747386bdf39846237">More...</a><br /></td></tr>
<tr class="separator:a29729f4b68c699f747386bdf39846237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832fe96bf501b3617ffbd46576d6fd0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a832fe96bf501b3617ffbd46576d6fd0c">vmFreeEDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a832fe96bf501b3617ffbd46576d6fd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a5d01bd5ab04517acef1d876f3989a8cd" title="Allocates memory for the quantity  on the GPU.">vmMallocEDevice()</a>.  <a href="metadata_8c.html#a832fe96bf501b3617ffbd46576d6fd0c">More...</a><br /></td></tr>
<tr class="separator:a832fe96bf501b3617ffbd46576d6fd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ba677ade4899d0040408fa210dddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a9a9ba677ade4899d0040408fa210dddb">vmFreeSDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a9a9ba677ade4899d0040408fa210dddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a50396fdf6698e705b50d7406d542b8ff" title="Allocates memory for the quantity  on the GPU.">vmMallocSDevice()</a>.  <a href="metadata_8c.html#a9a9ba677ade4899d0040408fa210dddb">More...</a><br /></td></tr>
<tr class="separator:a9a9ba677ade4899d0040408fa210dddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5491e983adc3a6b38ec7c08e2ea51c01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a5491e983adc3a6b38ec7c08e2ea51c01">vmFreeJDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a5491e983adc3a6b38ec7c08e2ea51c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a72bad3929557f04d2d1eb98fd554f303" title="Allocates memory for the quantity  on the GPU.">vmMallocJDevice()</a>.  <a href="metadata_8c.html#a5491e983adc3a6b38ec7c08e2ea51c01">More...</a><br /></td></tr>
<tr class="separator:a5491e983adc3a6b38ec7c08e2ea51c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4ff2689ea7a1cc6d1d106e2d0fcad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a4f4ff2689ea7a1cc6d1d106e2d0fcad4">vmFreeDDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a4f4ff2689ea7a1cc6d1d106e2d0fcad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a0d07ad1565f6716220a662fc7ad08273" title="Allocates memory for the quantity  on the GPU.">vmMallocDDevice()</a>.  <a href="metadata_8c.html#a4f4ff2689ea7a1cc6d1d106e2d0fcad4">More...</a><br /></td></tr>
<tr class="separator:a4f4ff2689ea7a1cc6d1d106e2d0fcad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad283d5d365c73152b2a748e84a7dc6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#ad283d5d365c73152b2a748e84a7dc6bc">vmFreePQIdxsDevice</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:ad283d5d365c73152b2a748e84a7dc6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated with <a class="el" href="metadata_8c.html#a69e06ca450bcb8b3e922093a4c0b34c0" title="Allocates memory for the polarisation indexes on the GPU.">vmMallocPQIdxsDevice()</a>.  <a href="metadata_8c.html#ad283d5d365c73152b2a748e84a7dc6bc">More...</a><br /></td></tr>
<tr class="separator:ad283d5d365c73152b2a748e84a7dc6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64484b56ded28eedc6615f980d4039a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a64484b56ded28eedc6615f980d4039a2">vmSetMaxGPUMem</a> (vcsbeam_context *vm, uintptr_t max_gpu_mem_bytes)</td></tr>
<tr class="memdesc:a64484b56ded28eedc6615f980d4039a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to cleverly figure out how many chunks are needed to fit everything on the GPU.  <a href="metadata_8c.html#a64484b56ded28eedc6615f980d4039a2">More...</a><br /></td></tr>
<tr class="separator:a64484b56ded28eedc6615f980d4039a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e140f229ab6d67dd32a403dd6f1521e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a6e140f229ab6d67dd32a403dd6f1521e">vmPushChunk</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a6e140f229ab6d67dd32a403dd6f1521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a "chunk" of input data onto the GPU.  <a href="metadata_8c.html#a6e140f229ab6d67dd32a403dd6f1521e">More...</a><br /></td></tr>
<tr class="separator:a6e140f229ab6d67dd32a403dd6f1521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46564605d923a726165f118fdb5d7998"><td class="memItemLeft" align="right" valign="top">vm_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a46564605d923a726165f118fdb5d7998">vmReadNextSecond</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a46564605d923a726165f118fdb5d7998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a second's worth of input data from the observation files.  <a href="metadata_8c.html#a46564605d923a726165f118fdb5d7998">More...</a><br /></td></tr>
<tr class="separator:a46564605d923a726165f118fdb5d7998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61586e2cdb871f45ece427179a31c404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a61586e2cdb871f45ece427179a31c404">vmPushJ</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a61586e2cdb871f45ece427179a31c404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the Jones matrices onto the GPU.  <a href="metadata_8c.html#a61586e2cdb871f45ece427179a31c404">More...</a><br /></td></tr>
<tr class="separator:a61586e2cdb871f45ece427179a31c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553000b93ec4a636103ace2f93728560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a553000b93ec4a636103ace2f93728560">vmCreateCudaStreams</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a553000b93ec4a636103ace2f93728560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up CUDA streams for multi-pixel beamforming.  <a href="metadata_8c.html#a553000b93ec4a636103ace2f93728560">More...</a><br /></td></tr>
<tr class="separator:a553000b93ec4a636103ace2f93728560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93726529c4f97621dae2adb6e6be44d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#ab93726529c4f97621dae2adb6e6be44d">vmDestroyCudaStreams</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:ab93726529c4f97621dae2adb6e6be44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the CUDA streams that were set up for multi-pixel beamforming.  <a href="metadata_8c.html#ab93726529c4f97621dae2adb6e6be44d">More...</a><br /></td></tr>
<tr class="separator:ab93726529c4f97621dae2adb6e6be44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870c4258461ba741f1a472d5f36e5c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a870c4258461ba741f1a472d5f36e5c4a">vmCreateStatistics</a> (vcsbeam_context *vm, mpi_psrfits *mpfs)</td></tr>
<tr class="memdesc:a870c4258461ba741f1a472d5f36e5c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates both CPU and GPU memory for the scales, offsets, and data for PSRFITS output.  <a href="metadata_8c.html#a870c4258461ba741f1a472d5f36e5c4a">More...</a><br /></td></tr>
<tr class="separator:a870c4258461ba741f1a472d5f36e5c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07553cefed331d77923def1f666e7b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a07553cefed331d77923def1f666e7b8d">vmDestroyStatistics</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a07553cefed331d77923def1f666e7b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees both the CPU and GPU memory for the scales, offsets, and data for PSRFITS output.  <a href="metadata_8c.html#a07553cefed331d77923def1f666e7b8d">More...</a><br /></td></tr>
<tr class="separator:a07553cefed331d77923def1f666e7b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3c45f755775cff7916efc2d9bc421a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#afc3c45f755775cff7916efc2d9bc421a">vmSetNumPointings</a> (vcsbeam_context *vm, unsigned int npointings)</td></tr>
<tr class="memdesc:afc3c45f755775cff7916efc2d9bc421a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of pointings.  <a href="metadata_8c.html#afc3c45f755775cff7916efc2d9bc421a">More...</a><br /></td></tr>
<tr class="separator:afc3c45f755775cff7916efc2d9bc421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa5b5d36fff7abca183cde80403aea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a06fa5b5d36fff7abca183cde80403aea">vmCreateFilenames</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a06fa5b5d36fff7abca183cde80403aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a list of file names for the input data.  <a href="metadata_8c.html#a06fa5b5d36fff7abca183cde80403aea">More...</a><br /></td></tr>
<tr class="separator:a06fa5b5d36fff7abca183cde80403aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5ec35f3e4f0cdce631cd30698b0f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a8c5ec35f3e4f0cdce631cd30698b0f50">vmGetVoltFilename</a> (vcsbeam_context *vm, unsigned int coarse_chan_idx, uint64_t gps_second, char *filename)</td></tr>
<tr class="memdesc:a8c5ec35f3e4f0cdce631cd30698b0f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input file name for the given channel index and GPS second.  <a href="metadata_8c.html#a8c5ec35f3e4f0cdce631cd30698b0f50">More...</a><br /></td></tr>
<tr class="separator:a8c5ec35f3e4f0cdce631cd30698b0f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229dbe21a869afa361c5adb778b6b580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a229dbe21a869afa361c5adb778b6b580">vmGetLegacyVoltFilename</a> (vcsbeam_context *vm, unsigned int coarse_chan_idx, uint64_t gps_second, char *filename)</td></tr>
<tr class="memdesc:a229dbe21a869afa361c5adb778b6b580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file name for the given channel index and GPS, as if the observation were a Legacy VCS observation.  <a href="metadata_8c.html#a229dbe21a869afa361c5adb778b6b580">More...</a><br /></td></tr>
<tr class="separator:a229dbe21a869afa361c5adb778b6b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566dda28b9125ec28035c34ec7c1e8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a566dda28b9125ec28035c34ec7c1e8a8">vmDestroyFilenames</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a566dda28b9125ec28035c34ec7c1e8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the list of input file names.  <a href="metadata_8c.html#a566dda28b9125ec28035c34ec7c1e8a8">More...</a><br /></td></tr>
<tr class="separator:a566dda28b9125ec28035c34ec7c1e8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af099b0fb461ccabfdaf1955884247ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#af099b0fb461ccabfdaf1955884247ab6">vmLoadObsMetafits</a> (vcsbeam_context *vm, char *filename)</td></tr>
<tr class="memdesc:af099b0fb461ccabfdaf1955884247ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an observation's metadata from its metafits file.  <a href="metadata_8c.html#af099b0fb461ccabfdaf1955884247ab6">More...</a><br /></td></tr>
<tr class="separator:af099b0fb461ccabfdaf1955884247ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548c18ab7cdf0c364bd04e2f6449584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a1548c18ab7cdf0c364bd04e2f6449584">vmLoadCalMetafits</a> (vcsbeam_context *vm, char *filename)</td></tr>
<tr class="memdesc:a1548c18ab7cdf0c364bd04e2f6449584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a calibration observation's metadata from its metafits file.  <a href="metadata_8c.html#a1548c18ab7cdf0c364bd04e2f6449584">More...</a><br /></td></tr>
<tr class="separator:a1548c18ab7cdf0c364bd04e2f6449584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6a7200e763b579248c859c42e34a0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a0e6a7200e763b579248c859c42e34a0a">vmGetVoltageMetadata</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a0e6a7200e763b579248c859c42e34a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the voltage metadata structs using mwalib's API.  <a href="metadata_8c.html#a0e6a7200e763b579248c859c42e34a0a">More...</a><br /></td></tr>
<tr class="separator:a0e6a7200e763b579248c859c42e34a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f36316d98d4277debe3df18d24fb61"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a57f36316d98d4277debe3df18d24fb61">get_relative_gps</a> (MetafitsMetadata *obs_metadata, long int relative_begin)</td></tr>
<tr class="memdesc:a57f36316d98d4277debe3df18d24fb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the GPS second for an observation from a relative offset value.  <a href="metadata_8c.html#a57f36316d98d4277debe3df18d24fb61">More...</a><br /></td></tr>
<tr class="separator:a57f36316d98d4277debe3df18d24fb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a4bbedbfda062ae4298c23c8969c19"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a34a4bbedbfda062ae4298c23c8969c19">parse_begin_string</a> (MetafitsMetadata *obs_metadata, char *begin_str)</td></tr>
<tr class="memdesc:a34a4bbedbfda062ae4298c23c8969c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the GPS second from a string representation of either a relative or absolute value.  <a href="metadata_8c.html#a34a4bbedbfda062ae4298c23c8969c19">More...</a><br /></td></tr>
<tr class="separator:a34a4bbedbfda062ae4298c23c8969c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9724ecfbe52d405c909bc55348480000"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a9724ecfbe52d405c909bc55348480000">parse_coarse_chan_string</a> (MetafitsMetadata *obs_metadata, char *begin_coarse_chan_str)</td></tr>
<tr class="memdesc:a9724ecfbe52d405c909bc55348480000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the coarse channel index from a string representation of either a relative or absolute value.  <a href="metadata_8c.html#a9724ecfbe52d405c909bc55348480000">More...</a><br /></td></tr>
<tr class="separator:a9724ecfbe52d405c909bc55348480000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd91a3f5247af33189f1effe62aa0db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#acdd91a3f5247af33189f1effe62aa0db">vmSetNumNotFlaggedRFInputs</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:acdd91a3f5247af33189f1effe62aa0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of tiles that are not flagged.  <a href="metadata_8c.html#acdd91a3f5247af33189f1effe62aa0db">More...</a><br /></td></tr>
<tr class="separator:acdd91a3f5247af33189f1effe62aa0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d853ac3d676a359d9c68e38c79c2a32"><td class="memItemLeft" align="right" valign="top">Rfinput *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a0d853ac3d676a359d9c68e38c79c2a32">find_matching_rf_input</a> (MetafitsMetadata *metadata, Rfinput *rfinput)</td></tr>
<tr class="memdesc:a0d853ac3d676a359d9c68e38c79c2a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a matching RF input in the given metadata.  <a href="metadata_8c.html#a0d853ac3d676a359d9c68e38c79c2a32">More...</a><br /></td></tr>
<tr class="separator:a0d853ac3d676a359d9c68e38c79c2a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb9bdbc06d3edb920bbbcd6724b4436"><td class="memItemLeft" align="right" valign="top">Antenna *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a5fb9bdbc06d3edb920bbbcd6724b4436">find_matching_antenna</a> (MetafitsMetadata *metadata, Rfinput *rfinput)</td></tr>
<tr class="memdesc:a5fb9bdbc06d3edb920bbbcd6724b4436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a matching Antenna in the given metadata.  <a href="metadata_8c.html#a5fb9bdbc06d3edb920bbbcd6724b4436">More...</a><br /></td></tr>
<tr class="separator:a5fb9bdbc06d3edb920bbbcd6724b4436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2d745e345db1a3f1390bc4b70f660c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#aad2d745e345db1a3f1390bc4b70f660c">get_mwalib_version</a> (char *version_str)</td></tr>
<tr class="memdesc:aad2d745e345db1a3f1390bc4b70f660c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mwalib version.  <a href="metadata_8c.html#aad2d745e345db1a3f1390bc4b70f660c">More...</a><br /></td></tr>
<tr class="separator:aad2d745e345db1a3f1390bc4b70f660c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad75716ad2b9634471e117eee8a2f343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#aad75716ad2b9634471e117eee8a2f343">vmParsePointingFile</a> (vcsbeam_context *vm, const char *filename)</td></tr>
<tr class="memdesc:aad75716ad2b9634471e117eee8a2f343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses RA/Dec pointings from a file.  <a href="metadata_8c.html#aad75716ad2b9634471e117eee8a2f343">More...</a><br /></td></tr>
<tr class="separator:aad75716ad2b9634471e117eee8a2f343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d8b5d03b2d35fd98551c49fc7b3627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a82d8b5d03b2d35fd98551c49fc7b3627">vmReportPerformanceStats</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a82d8b5d03b2d35fd98551c49fc7b3627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all performance statistics.  <a href="metadata_8c.html#a82d8b5d03b2d35fd98551c49fc7b3627">More...</a><br /></td></tr>
<tr class="separator:a82d8b5d03b2d35fd98551c49fc7b3627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e97955d5268461f318698179536d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metadata_8c.html#a991e97955d5268461f318698179536d1">vmPrintTitle</a> (vcsbeam_context *vm, const char *title)</td></tr>
<tr class="memdesc:a991e97955d5268461f318698179536d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a title to the specified log output stream.  <a href="metadata_8c.html#a991e97955d5268461f318698179536d1">More...</a><br /></td></tr>
<tr class="separator:a991e97955d5268461f318698179536d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aac8b4c5ae6f35a9e2992867e6ba2cbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8b4c5ae6f35a9e2992867e6ba2cbfe">&#9670;&nbsp;</a></span>destroy_vcsbeam_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_vcsbeam_context </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory associated with the VCSBeam context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>After freeing the memory associated with the VCSBeam context's member variables, this function frees the VCSBeam context itself.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>Rename this function to a <code>vm...</code> name </dd></dl>

</div>
</div>
<a id="a6e0a6247393ba2c9f493315c21005fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0a6247393ba2c9f493315c21005fcd">&#9670;&nbsp;</a></span>find_antenna_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Antenna* find_antenna_by_name </td>
          <td>(</td>
          <td class="paramtype">MetafitsMetadata *&#160;</td>
          <td class="paramname"><em>obs_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tile_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an antenna in an observation with a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obs_metadata</td><td>The observation metadata to be searched </td></tr>
    <tr><td class="paramname">tile_name</td><td>The name of the tile being sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an mwalib Antenna struct with a matching tile name</dd></dl>
<p>If no tile with the given name is found in the observation, <code>NULL</code> is returned. </p>

</div>
</div>
<a id="a5fb9bdbc06d3edb920bbbcd6724b4436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb9bdbc06d3edb920bbbcd6724b4436">&#9670;&nbsp;</a></span>find_matching_antenna()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Antenna* find_matching_antenna </td>
          <td>(</td>
          <td class="paramtype">MetafitsMetadata *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rfinput *&#160;</td>
          <td class="paramname"><em>rfinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a matching Antenna in the given metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>The metadata to be searched </td></tr>
    <tr><td class="paramname">rfinput</td><td>The RF input being sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matching struct in <code>metadata</code></dd></dl>
<p>This function goes through the antennas in <code>metadata</code>, searching for one that matches <code>rfinput</code>. A "match" is an RF input that has the same <code>tile_id</code>. If no match is found, <code>NULL</code> is returned. </p>

</div>
</div>
<a id="a0d853ac3d676a359d9c68e38c79c2a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d853ac3d676a359d9c68e38c79c2a32">&#9670;&nbsp;</a></span>find_matching_rf_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rfinput* find_matching_rf_input </td>
          <td>(</td>
          <td class="paramtype">MetafitsMetadata *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rfinput *&#160;</td>
          <td class="paramname"><em>rfinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a matching RF input in the given metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>The metadata to be searched </td></tr>
    <tr><td class="paramname">rfinput</td><td>The RF input being sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matching struct in <code>metadata</code></dd></dl>
<p>This function goes through the RF inputs in <code>metadata</code>, searching for one that matches <code>rfinput</code>. A "match" is an RF input that has the same <code>tile_id</code> and <code>pol</code>. If no match is found, <code>NULL</code> is returned. </p>

</div>
</div>
<a id="aad2d745e345db1a3f1390bc4b70f660c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2d745e345db1a3f1390bc4b70f660c">&#9670;&nbsp;</a></span>get_mwalib_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_mwalib_version </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>version_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mwalib version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">version_str</td><td>A buffer to hold the version string</td></tr>
  </table>
  </dd>
</dl>
<p>This function assumes that <code>version_str</code> is already allocated, and is big enough </p>

</div>
</div>
<a id="a57f36316d98d4277debe3df18d24fb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f36316d98d4277debe3df18d24fb61">&#9670;&nbsp;</a></span>get_relative_gps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int get_relative_gps </td>
          <td>(</td>
          <td class="paramtype">MetafitsMetadata *&#160;</td>
          <td class="paramname"><em>obs_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>relative_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the GPS second for an observation from a relative offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obs_metadata</td><td>The observation's metadata </td></tr>
    <tr><td class="paramname">relative_begin</td><td>An offset number of seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An absolute GPS second</dd></dl>
<p>If <code>relative_begin</code> &gt;= 0, then return the GPS second relative to the "good
time" (i.e. from the beginning of the observation). If <code>relative_begin</code> &lt; 0, then return the GPS second relative to the end of the observation.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>relative_begin</code>   </th><th class="markdownTableHeadLeft">GPS second    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyLeft">1st "good" second    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyLeft">2nd "good" second    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyLeft">3rd "good" second    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">...   </td><td class="markdownTableBodyLeft">...    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">-2   </td><td class="markdownTableBodyLeft">2nd last second    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">-1   </td><td class="markdownTableBodyLeft">Last second   </td></tr>
</table>

</div>
</div>
<a id="a34a4bbedbfda062ae4298c23c8969c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a4bbedbfda062ae4298c23c8969c19">&#9670;&nbsp;</a></span>parse_begin_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int parse_begin_string </td>
          <td>(</td>
          <td class="paramtype">MetafitsMetadata *&#160;</td>
          <td class="paramname"><em>obs_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>begin_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the GPS second from a string representation of either a relative or absolute value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obs_metadata</td><td>The observation's metadata </td></tr>
    <tr><td class="paramname">begin_str</td><td>A string representation of either a relative or absolute GPS second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An absolute GPS second</dd></dl>
<p>If the first character of <code>begin_str</code> is '<code>+</code>' or '<code>-</code>', then return a relative GPS second according to <a class="el" href="metadata_8c.html#a57f36316d98d4277debe3df18d24fb61" title="Gets the GPS second for an observation from a relative offset value.">get_relative_gps()</a>. Otherwise, parse it as a GPS second in its own right.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a9724ecfbe52d405c909bc55348480000" title="Gets the coarse channel index from a string representation of either a relative or absolute value.">parse_coarse_chan_string()</a> </dd>
<dd>
<a class="el" href="metadata_8c.html#a57f36316d98d4277debe3df18d24fb61" title="Gets the GPS second for an observation from a relative offset value.">get_relative_gps()</a> </dd></dl>

</div>
</div>
<a id="a9724ecfbe52d405c909bc55348480000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9724ecfbe52d405c909bc55348480000">&#9670;&nbsp;</a></span>parse_coarse_chan_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t parse_coarse_chan_string </td>
          <td>(</td>
          <td class="paramtype">MetafitsMetadata *&#160;</td>
          <td class="paramname"><em>obs_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>begin_coarse_chan_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the coarse channel index from a string representation of either a relative or absolute value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obs_metadata</td><td>The observation's metadata </td></tr>
    <tr><td class="paramname">begin_coarse_chan_str</td><td>A string representation of either a relative or absolute coarse channel index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An absolute coarse channel index</dd></dl>
<p>If the first character of <code>begin_coarse_chan_str</code> is '<code>+</code>' or '<code>-</code>', then return the coarse channel index relative to the lowest or highest coarse channel, respectively (with "-1" representing the highest channel, "-2" the second highest, etc.). Otherwise, parse it as a coarse channel index in its own right.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a34a4bbedbfda062ae4298c23c8969c19" title="Gets the GPS second from a string representation of either a relative or absolute value.">parse_begin_string()</a> </dd></dl>

</div>
</div>
<a id="a6d82fbfb82a80d86875463d9cc542486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d82fbfb82a80d86875463d9cc542486">&#9670;&nbsp;</a></span>vmBindCalibrationData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmBindCalibrationData </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>caldir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cal_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_bandpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>flags_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds a calibration solution to the VCSBeam context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">caldir</td><td>The directory containing RTS solution files, OR the path of an Offringa-style calibration solution file </td></tr>
    <tr><td class="paramname">cal_type</td><td>Either <code>CAL_RTS</code> or <code>CAL_OFFRINGA</code> </td></tr>
    <tr><td class="paramname">use_bandpass</td><td>Whether to include the Bandpass information (relevant for RTS solutions only) </td></tr>
    <tr><td class="paramname">flags_file</td><td>A file containing names of (extra) tiles to be flagged, or <code>NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a091372039dcad27a96221fa22cd58d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091372039dcad27a96221fa22cd58d5e">&#9670;&nbsp;</a></span>vmBindObsData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmBindObsData </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first_coarse_chan_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_coarse_chans_to_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_chan_idx_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>first_gps_second_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_gps_seconds_to_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gps_second_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>datadir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds a set of observation files to the VCSBeam context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">first_coarse_chan_str</td><td>A string representation of the lowest coarse channel to be processed </td></tr>
    <tr><td class="paramname">num_coarse_chans_to_process</td><td>The number of coarse channels to be processed </td></tr>
    <tr><td class="paramname">coarse_chan_idx_offset</td><td>The first coarse channel (relative to <code>first_coarse_chan_str</code>) to be processed by this MPI process </td></tr>
    <tr><td class="paramname">first_gps_second_str</td><td>A string representation of the first GPS second to be processed </td></tr>
    <tr><td class="paramname">num_gps_seconds_to_process</td><td>The number of GPS seconds to be processed </td></tr>
    <tr><td class="paramname">gps_second_offset</td><td>The first GPS second (relative to <code>first_gps_second_str</code>) to be processed by this MPI process </td></tr>
    <tr><td class="paramname">datadir</td><td>The directory containing the observation data files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a553000b93ec4a636103ace2f93728560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553000b93ec4a636103ace2f93728560">&#9670;&nbsp;</a></span>vmCreateCudaStreams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmCreateCudaStreams </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up CUDA streams for multi-pixel beamforming. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#ab93726529c4f97621dae2adb6e6be44d" title="Destroys the CUDA streams that were set up for multi-pixel beamforming.">vmDestroyCudaStreams()</a> </dd></dl>

</div>
</div>
<a id="a06fa5b5d36fff7abca183cde80403aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fa5b5d36fff7abca183cde80403aea">&#9670;&nbsp;</a></span>vmCreateFilenames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmCreateFilenames </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a list of file names for the input data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>This function creates an array of file names that are passed to mwalib to manage the reading in of the data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a566dda28b9125ec28035c34ec7c1e8a8" title="Destroys the list of input file names.">vmDestroyFilenames()</a> </dd></dl>

</div>
</div>
<a id="a870c4258461ba741f1a472d5f36e5c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870c4258461ba741f1a472d5f36e5c4a">&#9670;&nbsp;</a></span>vmCreateStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmCreateStatistics </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mpi_psrfits *&#160;</td>
          <td class="paramname"><em>mpfs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates both CPU and GPU memory for the scales, offsets, and data for PSRFITS output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">mpfs</td><td>A pointer to a MPI PSRFITS struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a07553cefed331d77923def1f666e7b8d" title="Frees both the CPU and GPU memory for the scales, offsets, and data for PSRFITS output.">vmDestroyStatistics()</a> </dd></dl>

</div>
</div>
<a id="ab93726529c4f97621dae2adb6e6be44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93726529c4f97621dae2adb6e6be44d">&#9670;&nbsp;</a></span>vmDestroyCudaStreams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmDestroyCudaStreams </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the CUDA streams that were set up for multi-pixel beamforming. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a553000b93ec4a636103ace2f93728560" title="Sets up CUDA streams for multi-pixel beamforming.">vmCreateCudaStreams()</a> </dd></dl>

</div>
</div>
<a id="a566dda28b9125ec28035c34ec7c1e8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566dda28b9125ec28035c34ec7c1e8a8">&#9670;&nbsp;</a></span>vmDestroyFilenames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmDestroyFilenames </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the list of input file names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a06fa5b5d36fff7abca183cde80403aea" title="Creates a list of file names for the input data.">vmCreateFilenames()</a> </dd></dl>

</div>
</div>
<a id="a07553cefed331d77923def1f666e7b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07553cefed331d77923def1f666e7b8d">&#9670;&nbsp;</a></span>vmDestroyStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmDestroyStatistics </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees both the CPU and GPU memory for the scales, offsets, and data for PSRFITS output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a870c4258461ba741f1a472d5f36e5c4a" title="Allocates both CPU and GPU memory for the scales, offsets, and data for PSRFITS output.">vmCreateStatistics()</a> </dd></dl>

</div>
</div>
<a id="a4f4ff2689ea7a1cc6d1d106e2d0fcad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4ff2689ea7a1cc6d1d106e2d0fcad4">&#9670;&nbsp;</a></span>vmFreeDDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeDDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a0d07ad1565f6716220a662fc7ad08273" title="Allocates memory for the quantity  on the GPU.">vmMallocDDevice()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae991cd418cfdccd1956ee2f81f42634a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae991cd418cfdccd1956ee2f81f42634a">&#9670;&nbsp;</a></span>vmFreeDHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeDHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a403313a0a88799c37b5424c922cc164c" title="Allocates memory for the quantity  on the CPU.">vmMallocDHost()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a832fe96bf501b3617ffbd46576d6fd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832fe96bf501b3617ffbd46576d6fd0c">&#9670;&nbsp;</a></span>vmFreeEDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeEDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a5d01bd5ab04517acef1d876f3989a8cd" title="Allocates memory for the quantity  on the GPU.">vmMallocEDevice()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f60270f9a62f1a8ad55d550f9a00474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f60270f9a62f1a8ad55d550f9a00474">&#9670;&nbsp;</a></span>vmFreeEHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeEHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#aae5f9e8e858b0534cfc164d1eebde98f" title="Allocates memory for the quantity  on the CPU.">vmMallocEHost()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5491e983adc3a6b38ec7c08e2ea51c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5491e983adc3a6b38ec7c08e2ea51c01">&#9670;&nbsp;</a></span>vmFreeJDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeJDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a72bad3929557f04d2d1eb98fd554f303" title="Allocates memory for the quantity  on the GPU.">vmMallocJDevice()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b8e5a587f033a1c98faf661d99f7685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8e5a587f033a1c98faf661d99f7685">&#9670;&nbsp;</a></span>vmFreeJHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeJHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#aa524cc6f8c6bad8c8e2c76d2e4717de5" title="Allocates memory for the quantity  on the CPU.">vmMallocJHost()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29729f4b68c699f747386bdf39846237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29729f4b68c699f747386bdf39846237">&#9670;&nbsp;</a></span>vmFreeJVDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeJVDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a242cfb9b89103a9e46ac36e7cd2bf3cc" title="Allocates memory for the quantities  on the GPU.">vmMallocJVDevice()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad91c35892c7153ae8519bfc4daee2f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91c35892c7153ae8519bfc4daee2f8d">&#9670;&nbsp;</a></span>vmFreeJVHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeJVHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a8152b712ffd26aee6aede80c746231ac" title="Allocates memory for the quantity  on the CPU.">vmMallocJVHost()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad283d5d365c73152b2a748e84a7dc6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad283d5d365c73152b2a748e84a7dc6bc">&#9670;&nbsp;</a></span>vmFreePQIdxsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreePQIdxsDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a69e06ca450bcb8b3e922093a4c0b34c0" title="Allocates memory for the polarisation indexes on the GPU.">vmMallocPQIdxsDevice()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a237de08cf463348bcb41139fd31c8271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237de08cf463348bcb41139fd31c8271">&#9670;&nbsp;</a></span>vmFreePQIdxsHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreePQIdxsHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#abdefe77192dfcbdfb6c1a986cdce5f5f" title="Allocates memory for the polarisation indexes on the CPU.">vmMallocPQIdxsHost()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9ba677ade4899d0040408fa210dddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9ba677ade4899d0040408fa210dddb">&#9670;&nbsp;</a></span>vmFreeSDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeSDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a50396fdf6698e705b50d7406d542b8ff" title="Allocates memory for the quantity  on the GPU.">vmMallocSDevice()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36f4b9a3f07109f98d2bc2bd2613e8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f4b9a3f07109f98d2bc2bd2613e8fd">&#9670;&nbsp;</a></span>vmFreeSHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeSHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated with <a class="el" href="metadata_8c.html#a31244370219af727e316abca277b4d98" title="Allocates memory for the quantity  on the CPU.">vmMallocSHost()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1eed0fa043bb2638293788d612c9457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1eed0fa043bb2638293788d612c9457">&#9670;&nbsp;</a></span>vmFreeVDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeVDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the GPU memory allocated with <a class="el" href="metadata_8c.html#a9f21fd4f1390ced2d339afacdfe34fdd" title="Allocates memory for the input voltages on the GPU.">vmMallocVDevice()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>If the observation is Legacy, then free the memory.</p>
<p>If the observation is MWAX, then do nothing; the memory should be freed via a call to <a class="el" href="pfb_8cu.html#a54059e7d31bcf4eccc39609e72ad8189" title="Frees host and device memory allocated in vmInitForwardPFB().">vmFreeForwardPFB()</a>. </p>

</div>
</div>
<a id="a3afb5e0fe27c01f9b23a3eabb7b37092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afb5e0fe27c01f9b23a3eabb7b37092">&#9670;&nbsp;</a></span>vmFreeVHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeVHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated for the input voltages on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a229dbe21a869afa361c5adb778b6b580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229dbe21a869afa361c5adb778b6b580">&#9670;&nbsp;</a></span>vmGetLegacyVoltFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmGetLegacyVoltFilename </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>coarse_chan_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>gps_second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the file name for the given channel index and GPS, as if the observation were a Legacy VCS observation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarse_chan_idx</td><td>The index of a coarse channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gps_second</td><td>A GPS second </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filename</td><td>A buffer for the filename</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the filename for the observation referred to in <code>vm&rarr;obs_context_legacy</code>.</p>
<p><code>filename</code> must point to already-allocated memory.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a8c5ec35f3e4f0cdce631cd30698b0f50" title="Gets the input file name for the given channel index and GPS second.">vmGetVoltFilename()</a> </dd></dl>

</div>
</div>
<a id="a0e6a7200e763b579248c859c42e34a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6a7200e763b579248c859c42e34a0a">&#9670;&nbsp;</a></span>vmGetVoltageMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmGetVoltageMetadata </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the voltage metadata structs using mwalib's API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>This function should only be called after <a class="el" href="metadata_8c.html#af099b0fb461ccabfdaf1955884247ab6" title="Loads an observation&#39;s metadata from its metafits file.">vmLoadObsMetafits()</a>. </p>

</div>
</div>
<a id="a8c5ec35f3e4f0cdce631cd30698b0f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5ec35f3e4f0cdce631cd30698b0f50">&#9670;&nbsp;</a></span>vmGetVoltFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmGetVoltFilename </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>coarse_chan_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>gps_second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the input file name for the given channel index and GPS second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarse_chan_idx</td><td>The index of a coarse channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gps_second</td><td>A GPS second </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filename</td><td>A buffer for the filename</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the filename for the observation referred to in <code>vm&rarr;obs_context</code>.</p>
<p>The variable <code>vm&rarr;seconds_per_file</code> must be set to the relevant value depending on whether the observation is Legacy (1) or MWAX (8), which is done via <a class="el" href="metadata_8c.html#af099b0fb461ccabfdaf1955884247ab6" title="Loads an observation&#39;s metadata from its metafits file.">vmLoadObsMetafits()</a>.</p>
<p><code>filename</code> must point to already-allocated memory.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="metadata_8c.html#a229dbe21a869afa361c5adb778b6b580" title="Gets the file name for the given channel index and GPS, as if the observation were a Legacy VCS obser...">vmGetLegacyVoltFilename()</a> </dd></dl>

</div>
</div>
<a id="a7a572becfecd297d68a8b296b29cd0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a572becfecd297d68a8b296b29cd0f8">&#9670;&nbsp;</a></span>vmInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcsbeam_context* vmInit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_mpi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a VCSBeam context struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_mpi</td><td>Set up the struct for using MPI </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly allocated <code>vcsbeam_context</code> struct</dd></dl>
<p>Once the VCSBeam context is finished with, it should be freed with a call to <a class="el" href="metadata_8c.html#aac8b4c5ae6f35a9e2992867e6ba2cbfe" title="Frees the memory associated with the VCSBeam context.">destroy_vcsbeam_context()</a>. </p>

</div>
</div>
<a id="a1548c18ab7cdf0c364bd04e2f6449584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548c18ab7cdf0c364bd04e2f6449584">&#9670;&nbsp;</a></span>vmLoadCalMetafits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmLoadCalMetafits </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a calibration observation's metadata from its metafits file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the metafits file to be loaded.</td></tr>
  </table>
  </dd>
</dl>
<p>This function loads the metadata into <code>vm&rarr;cal_context</code> and <code>vm&rarr;cal_metadata</code>, using mwalib's API. The observation to be loaded should be the calibration observation, i.e. the observation for which a calibration solution has been obtained. </p>

</div>
</div>
<a id="af099b0fb461ccabfdaf1955884247ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af099b0fb461ccabfdaf1955884247ab6">&#9670;&nbsp;</a></span>vmLoadObsMetafits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmLoadObsMetafits </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an observation's metadata from its metafits file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the metafits file to be loaded.</td></tr>
  </table>
  </dd>
</dl>
<p>This function loads the metadata into <code>vm&rarr;obs_context</code> and <code>vm&rarr;obs_metadata</code>, using mwalib's API. It also loads a "Legacy" version of the context into <code>vm&rarr;obs_context_legacy</code>. The observation to be loaded should be the "target" observation, i.e. the observation whose VCS data is to be processed. </p>

</div>
</div>
<a id="a0d07ad1565f6716220a662fc7ad08273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d07ad1565f6716220a662fc7ad08273">&#9670;&nbsp;</a></span>vmMallocDDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocDDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf D}\) on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;d_D</code>. </p>

</div>
</div>
<a id="a403313a0a88799c37b5424c922cc164c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403313a0a88799c37b5424c922cc164c">&#9670;&nbsp;</a></span>vmMallocDHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocDHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf D}\) on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;D</code>. </p>

</div>
</div>
<a id="a5d01bd5ab04517acef1d876f3989a8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d01bd5ab04517acef1d876f3989a8cd">&#9670;&nbsp;</a></span>vmMallocEDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocEDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf e}\) on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;d_e</code>. </p>

</div>
</div>
<a id="aae5f9e8e858b0534cfc164d1eebde98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5f9e8e858b0534cfc164d1eebde98f">&#9670;&nbsp;</a></span>vmMallocEHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocEHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf e}\) on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;e</code>. </p>

</div>
</div>
<a id="a72bad3929557f04d2d1eb98fd554f303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bad3929557f04d2d1eb98fd554f303">&#9670;&nbsp;</a></span>vmMallocJDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocJDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf J}\) on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;d_J</code>. </p>

</div>
</div>
<a id="aa524cc6f8c6bad8c8e2c76d2e4717de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa524cc6f8c6bad8c8e2c76d2e4717de5">&#9670;&nbsp;</a></span>vmMallocJHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocJHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf J}\) on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;J</code>. </p>

</div>
</div>
<a id="a242cfb9b89103a9e46ac36e7cd2bf3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242cfb9b89103a9e46ac36e7cd2bf3cc">&#9670;&nbsp;</a></span>vmMallocJVDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocJVDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantities \({\bf J}{\bf v}\) on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>Pointers to the newly allocated memory are given in <code>vm&rarr;d_Jv_P</code> and <code>vm&rarr;d_Jv_Q</code>.</p>
<p>Only one "chunk" of memory is allocated (where each second of input data is divided up into one or more chunks, depending on the amount of memory available on the GPU). </p>

</div>
</div>
<a id="a8152b712ffd26aee6aede80c746231ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8152b712ffd26aee6aede80c746231ac">&#9670;&nbsp;</a></span>vmMallocJVHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocJVHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf J}{\bf v}\) on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>Pointers to the newly allocated memory are given in <code>vm&rarr;Jv_P</code> and <code>vm&rarr;Jv_Q</code>. </p>

</div>
</div>
<a id="a69e06ca450bcb8b3e922093a4c0b34c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e06ca450bcb8b3e922093a4c0b34c0">&#9670;&nbsp;</a></span>vmMallocPQIdxsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocPQIdxsDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the polarisation indexes on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>Pointers to the newly allocated memory are given in <code>vm&rarr;d_polP_idxs</code> and <code>vm&rarr;d_polQ_idxs</code>. </p>

</div>
</div>
<a id="abdefe77192dfcbdfb6c1a986cdce5f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdefe77192dfcbdfb6c1a986cdce5f5f">&#9670;&nbsp;</a></span>vmMallocPQIdxsHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocPQIdxsHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the polarisation indexes on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>Pointers to the newly allocated memory are given in <code>vm&rarr;polP_idxs</code> and <code>vm&rarr;polQ_idxs</code>. </p>

</div>
</div>
<a id="a50396fdf6698e705b50d7406d542b8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50396fdf6698e705b50d7406d542b8ff">&#9670;&nbsp;</a></span>vmMallocSDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocSDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf S}\) on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;d_S</code>. </p>

</div>
</div>
<a id="a31244370219af727e316abca277b4d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31244370219af727e316abca277b4d98">&#9670;&nbsp;</a></span>vmMallocSHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocSHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the quantity \({\bf S}\) on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the newly allocated memory is given in <code>vm&rarr;S</code>. </p>

</div>
</div>
<a id="a9f21fd4f1390ced2d339afacdfe34fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f21fd4f1390ced2d339afacdfe34fdd">&#9670;&nbsp;</a></span>vmMallocVDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocVDevice </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the input voltages on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>If the observation is Legacy, then this function allocates new memory and sets <code>vm&rarr;d_v_size_bytes</code> to the address of the new memory block.</p>
<p>If the observation is MWAX, then this function only copies the value of <code>vm&rarr;fpfb&rarr;d_vcs_data</code> to <code>vm&rarr;d_v_size_bytes</code>, (without checking whether it points to valid GPU memory).</p>
<p>Only one "chunk" of memory is allocated (where each second of input data is divided up into one or more chunks, depending on the amount of memory available on the GPU). </p>

</div>
</div>
<a id="a724190b8e83033d8ab2b2e520e7b05b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724190b8e83033d8ab2b2e520e7b05b5">&#9670;&nbsp;</a></span>vmMallocVHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmMallocVHost </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for the input voltages on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>The memory is allocated as a <code>host_buffer</code> struct (see <a class="el" href="buffer_8c.html#ac3bea5a75804335dcce618820d5c28cf" title="Initialise a buffer for reading in voltage data.">vmInitReadBuffer()</a> for a full description). The amount of memory allocated depends on whether the observation is Legacy or MWAX.</p>
<p>If the input is legacy, the read buffer can be just enough for one second's worth of data.</p>
<p>However, for MWAX, the read buffer must be slightly bigger to accommodate the PFB's extra taps. (For now, this is fixed to one voltage block. Changing this will break the gpu kernels that do the fine PFB, for which the offset into the data is currently hard-coded.) </p>

</div>
</div>
<a id="aad75716ad2b9634471e117eee8a2f343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad75716ad2b9634471e117eee8a2f343">&#9670;&nbsp;</a></span>vmParsePointingFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmParsePointingFile </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses RA/Dec pointings from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the file to be parsed.</td></tr>
  </table>
  </dd>
</dl>
<p>The file must contain whitespace-separated RAs and Decs in the format <code>HH:MM:SS.S DD:MM:SS.S</code>.</p>
<p>This function allocates memory for ras_hours and decs_degs arrays, which will be destroyed during <a class="el" href="metadata_8c.html#aac8b4c5ae6f35a9e2992867e6ba2cbfe" title="Frees the memory associated with the VCSBeam context.">destroy_vcsbeam_context()</a>. </p>

</div>
</div>
<a id="a991e97955d5268461f318698179536d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e97955d5268461f318698179536d1">&#9670;&nbsp;</a></span>vmPrintTitle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmPrintTitle </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a title to the specified log output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">title</td><td>The text to be printed</td></tr>
  </table>
  </dd>
</dl>
<p>The text is printed in the format </p><div class="fragment"><div class="line">------- VCSBeam (VERSION): TITLE -------</div>
</div><!-- fragment --><p> with <code>VERSION</code> and <code>TITLE</code> being replaced with the VCSBeam version string and the specified title respectively. </p>

</div>
</div>
<a id="a6e140f229ab6d67dd32a403dd6f1521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e140f229ab6d67dd32a403dd6f1521e">&#9670;&nbsp;</a></span>vmPushChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmPushChunk </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a "chunk" of input data onto the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61586e2cdb871f45ece427179a31c404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61586e2cdb871f45ece427179a31c404">&#9670;&nbsp;</a></span>vmPushJ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmPushJ </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the Jones matrices onto the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1824ef3922bf4cd94ba1d17d9b6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1824ef3922bf4cd94ba1d17d9b6789f">&#9670;&nbsp;</a></span>vmReadCalibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmReadCalibration </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in a calibration solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>Calls either <a class="el" href="calibration_8c.html#a456923a16ff4f680b225d49d7e5ebe63" title="Loads a Real Time System (RTS) calibration solution.">vmLoadRTSSolution()</a> or <a class="el" href="calibration_8c.html#a20eb84ad9699d8bc39c5f0001cf6b246" title="Reads in a calibration solution from an Offringa-style solution file.">vmLoadOffringaSolution()</a> depending on whether <code>vm&rarr;cal.cal_type</code> is set to <code>CAL_RTS</code> or <code>CAL_OFFRINGA</code>. Afterwards, <a class="el" href="calibration_8c.html#ad565f8bc38128d7645a55be24697ee6f" title="Flags tiles by setting the corresponding calibration matrices to zero.">vmSetCustomTileFlags()</a> is called. </p>

</div>
</div>
<a id="a46564605d923a726165f118fdb5d7998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46564605d923a726165f118fdb5d7998">&#9670;&nbsp;</a></span>vmReadNextSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vm_error vmReadNextSecond </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a second's worth of input data from the observation files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82d8b5d03b2d35fd98551c49fc7b3627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d8b5d03b2d35fd98551c49fc7b3627">&#9670;&nbsp;</a></span>vmReportPerformanceStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmReportPerformanceStats </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports all performance statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64484b56ded28eedc6615f980d4039a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64484b56ded28eedc6615f980d4039a2">&#9670;&nbsp;</a></span>vmSetMaxGPUMem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmSetMaxGPUMem </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>max_gpu_mem_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to cleverly figure out how many chunks are needed to fit everything on the GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">max_gpu_mem_bytes</td><td>The maximum amount of GPU memory (in bytes) to use</td></tr>
  </table>
  </dd>
</dl>
<p>LOGIC IS CURRENTLY FAULTY AND INCOMPLETE. DO NOT USE! </p>

</div>
</div>
<a id="acdd91a3f5247af33189f1effe62aa0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd91a3f5247af33189f1effe62aa0db">&#9670;&nbsp;</a></span>vmSetNumNotFlaggedRFInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmSetNumNotFlaggedRFInputs </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of tiles that are not flagged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct</td></tr>
  </table>
  </dd>
</dl>
<p>The result is stored in <code>vm&rarr;num_not_flagged</code>. </p>

</div>
</div>
<a id="afc3c45f755775cff7916efc2d9bc421a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3c45f755775cff7916efc2d9bc421a">&#9670;&nbsp;</a></span>vmSetNumPointings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmSetNumPointings </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>npointings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of pointings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npointings</td><td>The number of pointings</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>Investigate whether this function is really needed </dd></dl>

</div>
</div>
<a id="ab000c14b3b5a0101dc26391aa8c38c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab000c14b3b5a0101dc26391aa8c38c3d">&#9670;&nbsp;</a></span>vmSetOutputChannelisation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmSetOutputChannelisation </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>out_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>out_coarse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets flags governing whether the PFB and inverse PFB routines are run depending on the input and output channelisations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">out_fine</td><td>Sets the flag for fine channelised output </td></tr>
    <tr><td class="paramname">out_coarse</td><td>Sets the flag for coarse_channelised output</td></tr>
  </table>
  </dd>
</dl>
<p>Whether the (forward) PFB or the inverse PFB needs to be run depends on the input channelisation (fine = Legacy, or coarse = MWAX), and what channelisations are desired in output (fine or coarse). The <code>vm&rarr;do_forward_pfb</code> and <code>vm&rarr;do_inverse_pfb</code> are set accordingly.</p>
<p>The following table describes all possible scenarios: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Input mode   </th><th class="markdownTableHeadCenter">Output fine?   </th><th class="markdownTableHeadCenter">Output coarse?   </th><th class="markdownTableHeadCenter">Do forward PFB?   </th><th class="markdownTableHeadCenter">Do inverse PFB?    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Legacy   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Legacy   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Legacy   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Legacy   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">MWAX   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">no    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">MWAX   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">MWAX   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">no    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">MWAX   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">yes   </td><td class="markdownTableBodyCenter">yes   </td></tr>
</table>
<p>Note that both forward and inverse PFBs are required for MWAX data even when fine-channelised output is not requested. This is because the beamforming operation requires sufficiently fine channels in order to avoid decoherence across the channels. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VCSBeam: pfb.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_tiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VCSBeam
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pfb.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="gpu__fft_8hpp_source.html">gpu_fft.hpp</a>&quot;</code><br />
<code>#include &quot;gpu_macros.h&quot;</code><br />
<code>#include &lt;mwalib.h&gt;</code><br />
<code>#include &quot;vcsbeam.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pfb.cpp:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="pfb_8cpp__incl.svg" width="100%" height="440"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab30891f5325d182547a481d9143f490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#ab30891f5325d182547a481d9143f490d">gpuAssert</a> (gpuError_t code, const char *file, int line, bool abort=true)</td></tr>
<tr class="separator:ab30891f5325d182547a481d9143f490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7374f0e61cc4b19318b0aca79c8f40df"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a7374f0e61cc4b19318b0aca79c8f40df">vmWOLA_kernel</a> (char2 *indata, int *filter_coeffs, void *weighted_overlap_array)</td></tr>
<tr class="memdesc:a7374f0e61cc4b19318b0aca79c8f40df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the weighted overlap-add part of the PFB algorithm.  <a href="pfb_8cpp.html#a7374f0e61cc4b19318b0aca79c8f40df">More...</a><br /></td></tr>
<tr class="separator:a7374f0e61cc4b19318b0aca79c8f40df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d1c9b40a2932b8d4f48f76877207aa"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#aa5d1c9b40a2932b8d4f48f76877207aa">fpga_rounding_and_demotion</a> (void *data)</td></tr>
<tr class="memdesc:aa5d1c9b40a2932b8d4f48f76877207aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA kernel for performing the rounding and demotion step of the forward PFB.  <a href="pfb_8cpp.html#aa5d1c9b40a2932b8d4f48f76877207aa">More...</a><br /></td></tr>
<tr class="separator:aa5d1c9b40a2932b8d4f48f76877207aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd399e8c525feba6355ab52ba02a9f1f"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#afd399e8c525feba6355ab52ba02a9f1f">int2float</a> (void *data, double scale)</td></tr>
<tr class="memdesc:afd399e8c525feba6355ab52ba02a9f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 32-bit integers to 32-bit floats.  <a href="pfb_8cpp.html#afd399e8c525feba6355ab52ba02a9f1f">More...</a><br /></td></tr>
<tr class="separator:afd399e8c525feba6355ab52ba02a9f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a732480f8d3574b2916f75547ce1b7b"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a0a732480f8d3574b2916f75547ce1b7b">pack_into_recombined_format</a> (gpuFloatComplex *ffted, void *outdata, int *i_idx, pfb_flags flags)</td></tr>
<tr class="memdesc:a0a732480f8d3574b2916f75547ce1b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA kernel for packing the PFB'ed data into legacy recombined layout/format.  <a href="pfb_8cpp.html#a0a732480f8d3574b2916f75547ce1b7b">More...</a><br /></td></tr>
<tr class="separator:a0a732480f8d3574b2916f75547ce1b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c933bc8f363e9480d75f32c6720fe56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a9c933bc8f363e9480d75f32c6720fe56">vmInitForwardPFB</a> (vcsbeam_context *vm, int M, pfb_flags flags)</td></tr>
<tr class="memdesc:a9c933bc8f363e9480d75f32c6720fe56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialise a forward_pfb struct.  <a href="pfb_8cpp.html#a9c933bc8f363e9480d75f32c6720fe56">More...</a><br /></td></tr>
<tr class="separator:a9c933bc8f363e9480d75f32c6720fe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54059e7d31bcf4eccc39609e72ad8189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a54059e7d31bcf4eccc39609e72ad8189">vmFreeForwardPFB</a> (forward_pfb *fpfb)</td></tr>
<tr class="memdesc:a54059e7d31bcf4eccc39609e72ad8189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees host and device memory allocated in <a class="el" href="pfb_8cpp.html#a9c933bc8f363e9480d75f32c6720fe56" title="Create and initialise a forward_pfb struct.">vmInitForwardPFB()</a>.  <a href="pfb_8cpp.html#a54059e7d31bcf4eccc39609e72ad8189">More...</a><br /></td></tr>
<tr class="separator:a54059e7d31bcf4eccc39609e72ad8189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8ef7871feb4b480442a73482cb4903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#afd8ef7871feb4b480442a73482cb4903">vmUploadForwardPFBChunk</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:afd8ef7871feb4b480442a73482cb4903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a chunk of PFB data from CPU to GPU.  <a href="pfb_8cpp.html#afd8ef7871feb4b480442a73482cb4903">More...</a><br /></td></tr>
<tr class="separator:afd8ef7871feb4b480442a73482cb4903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353ec3d21419ab0192de2ea4771a77b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a353ec3d21419ab0192de2ea4771a77b3">vmWOLAChunk</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a353ec3d21419ab0192de2ea4771a77b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <a class="el" href="pfb_8cpp.html#a7374f0e61cc4b19318b0aca79c8f40df" title="Performs the weighted overlap-add part of the PFB algorithm.">vmWOLA_kernel()</a> kernel for the forward PFB data.  <a href="pfb_8cpp.html#a353ec3d21419ab0192de2ea4771a77b3">More...</a><br /></td></tr>
<tr class="separator:a353ec3d21419ab0192de2ea4771a77b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d546028e05c56e5bd4e53570054366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a51d546028e05c56e5bd4e53570054366">vmFPGARoundingChunk</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a51d546028e05c56e5bd4e53570054366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <a class="el" href="pfb_8cpp.html#aa5d1c9b40a2932b8d4f48f76877207aa" title="CUDA kernel for performing the rounding and demotion step of the forward PFB.">fpga_rounding_and_demotion()</a> kernel for the forward PFB data.  <a href="pfb_8cpp.html#a51d546028e05c56e5bd4e53570054366">More...</a><br /></td></tr>
<tr class="separator:a51d546028e05c56e5bd4e53570054366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d6f48661b1ee20194a9cdbb1370244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a25d6f48661b1ee20194a9cdbb1370244">vmFFTChunk</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a25d6f48661b1ee20194a9cdbb1370244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the (CUDA) FFT on the forward PFB data.  <a href="pfb_8cpp.html#a25d6f48661b1ee20194a9cdbb1370244">More...</a><br /></td></tr>
<tr class="separator:a25d6f48661b1ee20194a9cdbb1370244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ff9eb0026fbdcf87817dbeb746fad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#aa6ff9eb0026fbdcf87817dbeb746fad6">vmPackChunk</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:aa6ff9eb0026fbdcf87817dbeb746fad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <a class="el" href="pfb_8cpp.html#a0a732480f8d3574b2916f75547ce1b7b" title="CUDA kernel for packing the PFB&#39;ed data into legacy recombined layout/format.">pack_into_recombined_format()</a> kernel for the forward PFB data.  <a href="pfb_8cpp.html#aa6ff9eb0026fbdcf87817dbeb746fad6">More...</a><br /></td></tr>
<tr class="separator:aa6ff9eb0026fbdcf87817dbeb746fad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add07f7e3012c84b6d596b76d6ab1af82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#add07f7e3012c84b6d596b76d6ab1af82">vmDownloadForwardPFBChunk</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:add07f7e3012c84b6d596b76d6ab1af82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a chunk of PFB data from GPU to CPU.  <a href="pfb_8cpp.html#add07f7e3012c84b6d596b76d6ab1af82">More...</a><br /></td></tr>
<tr class="separator:add07f7e3012c84b6d596b76d6ab1af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718c0996f48d674e941efd897aa9ae8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a718c0996f48d674e941efd897aa9ae8f">vmExecuteForwardPFB</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a718c0996f48d674e941efd897aa9ae8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapper function that performs a forward PFB on the GPU.  <a href="pfb_8cpp.html#a718c0996f48d674e941efd897aa9ae8f">More...</a><br /></td></tr>
<tr class="separator:a718c0996f48d674e941efd897aa9ae8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831bf4d5d1a25ca5d2deeb0def57cd2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a831bf4d5d1a25ca5d2deeb0def57cd2a">vmWritePFBOutputToFile</a> (vcsbeam_context *vm)</td></tr>
<tr class="memdesc:a831bf4d5d1a25ca5d2deeb0def57cd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the result of the forward PFB operation to file.  <a href="pfb_8cpp.html#a831bf4d5d1a25ca5d2deeb0def57cd2a">More...</a><br /></td></tr>
<tr class="separator:a831bf4d5d1a25ca5d2deeb0def57cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eb2332a6371d8a576e6422d7bc9d79"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#aa6eb2332a6371d8a576e6422d7bc9d79">ipfb_kernel</a> (float *in_real, float *in_imag, float *ft_real, float *ft_imag, int ntaps, int npol, float *out)</td></tr>
<tr class="memdesc:aa6eb2332a6371d8a576e6422d7bc9d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA kernel implementing the synthesis PFB.  <a href="pfb_8cpp.html#aa6eb2332a6371d8a576e6422d7bc9d79">More...</a><br /></td></tr>
<tr class="separator:aa6eb2332a6371d8a576e6422d7bc9d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93d41ccc84ce6a6b1ca7232781cc252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#af93d41ccc84ce6a6b1ca7232781cc252">cu_invert_pfb</a> (gpuDoubleComplex *data_buffer_fine, int file_no, int npointing, int nsamples, int nchan, int npol, int sizeof_buffer, struct gpu_ipfb_arrays *g, float *data_buffer_vdif)</td></tr>
<tr class="memdesc:af93d41ccc84ce6a6b1ca7232781cc252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the PFB by applying a resynthesis filter, using GPU acceleration.  <a href="pfb_8cpp.html#af93d41ccc84ce6a6b1ca7232781cc252">More...</a><br /></td></tr>
<tr class="separator:af93d41ccc84ce6a6b1ca7232781cc252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45995dfe13bebd70b6d7806078fa6211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a45995dfe13bebd70b6d7806078fa6211">cu_load_ipfb_filter</a> (pfb_filter *filter, struct gpu_ipfb_arrays *g)</td></tr>
<tr class="memdesc:a45995dfe13bebd70b6d7806078fa6211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the inverse PFB filter coefficients to the GPU.  <a href="pfb_8cpp.html#a45995dfe13bebd70b6d7806078fa6211">More...</a><br /></td></tr>
<tr class="separator:a45995dfe13bebd70b6d7806078fa6211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6744a624a2063f1bce0e23ebf2880c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#a6744a624a2063f1bce0e23ebf2880c24">malloc_ipfb</a> (struct gpu_ipfb_arrays *g, pfb_filter *filter, int nsamples, int npol, int npointing)</td></tr>
<tr class="memdesc:a6744a624a2063f1bce0e23ebf2880c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate GPU memory needed for performing the inverse PFB.  <a href="pfb_8cpp.html#a6744a624a2063f1bce0e23ebf2880c24">More...</a><br /></td></tr>
<tr class="separator:a6744a624a2063f1bce0e23ebf2880c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e04314a805c456827f9b39c930180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfb_8cpp.html#ac08e04314a805c456827f9b39c930180">free_ipfb</a> (struct gpu_ipfb_arrays *g)</td></tr>
<tr class="memdesc:ac08e04314a805c456827f9b39c930180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the GPU memory allocated in <a class="el" href="pfb_8cpp.html#a6744a624a2063f1bce0e23ebf2880c24" title="Allocate GPU memory needed for performing the inverse PFB.">malloc_ipfb()</a>.  <a href="pfb_8cpp.html#ac08e04314a805c456827f9b39c930180">More...</a><br /></td></tr>
<tr class="separator:ac08e04314a805c456827f9b39c930180"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af93d41ccc84ce6a6b1ca7232781cc252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93d41ccc84ce6a6b1ca7232781cc252">&#9670;&nbsp;</a></span>cu_invert_pfb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cu_invert_pfb </td>
          <td>(</td>
          <td class="paramtype">gpuDoubleComplex *&#160;</td>
          <td class="paramname"><em>data_buffer_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npointing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nchan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeof_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct gpu_ipfb_arrays *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>data_buffer_vdif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the PFB by applying a resynthesis filter, using GPU acceleration. </p>
<p>This function expects <code>data_buffer_fine</code> to be a 1D array of complex voltages with indices following the ordering:</p>
<div class="fragment"><div class="line">pointing, samp, chan, pol</div>
</div><!-- fragment --><p>Although <code>data_buffer_fine</code> potentially contains 2 seconds' worth of data, this function only inverts 1 second. The appropriate second is worked out using <code>file_no</code>: if it is even, the first half of <code>data_buffer_fine</code> is used; if odd, the second half.</p>
<p>The IPFB is also given ntaps samples from the end of the previous second, so in total the IPFB is given nsamp+ntaps samples worth of data.</p>
<p>The output of the inversion is packed back into <code>data_buffer_vdif</code>, a 1D array whose ordering is as follows:</p>
<div class="fragment"><div class="line">time, pol, complexity</div>
</div><!-- fragment --><p>This ordering is suited for immediate output to the VDIF format.</p>
<p>It is assumed that the inverse filter coefficients have already been loaded to the GPU. </p>

</div>
</div>
<a id="a45995dfe13bebd70b6d7806078fa6211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45995dfe13bebd70b6d7806078fa6211">&#9670;&nbsp;</a></span>cu_load_ipfb_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cu_load_ipfb_filter </td>
          <td>(</td>
          <td class="paramtype">pfb_filter *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct gpu_ipfb_arrays *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the inverse PFB filter coefficients to the GPU. </p>
<p>This function loads the inverse filter coefficients and the twiddle factors into GPU memory. If they were loaded separately (as floats), then the multiplication of the filter coefficients and the twiddle factors will be less precise than if a single array containing every combination of floats and twiddle factors is calculated in doubles, and then demoted to floats. Hence, this pre-calculation is done in this function before gpuMemcpy is called.</p>
<p>The result is 2x 1D arrays loaded onto the GPU (one for real, one for imag) where the ith element is equal to </p><p class="formulaDsp">
\[ \text{result}[i] = f[n] \times exp{2\pi jk/K}, \]
</p>
<p> where \(n = i \% N\), \(k = i / N\), \(N\) is the filter size (<code>fil_size</code>) and \(K\) is the number of channels (<code>nchan</code>). </p>

</div>
</div>
<a id="aa5d1c9b40a2932b8d4f48f76877207aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d1c9b40a2932b8d4f48f76877207aa">&#9670;&nbsp;</a></span>fpga_rounding_and_demotion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void fpga_rounding_and_demotion </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUDA kernel for performing the rounding and demotion step of the forward PFB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>The data to be rounded and demoted.</td></tr>
  </table>
  </dd>
</dl>
<p>The rounding and demotion performed here is designed to emulate that done in the FPGAs of the legacy (Phases 1 &amp; 2) MWA system. Specifically, it does the following: </p><p class="formulaDsp">
\[ \begin{cases} \left\lfloor \frac{x}{2^{14}} + 0.5 \right\rfloor, &amp; x &gt; 0, \\ \left\lfloor \frac{x}{2^{14}} \right\rfloor, &amp; x \le 0. \end{cases} \]
</p>
<p> The final numbers are represented as 32-bit floats.</p>
<p>The expected thread configuration is \(\langle\langle\langle (\text{nspectra} \times I), K \rangle\rangle\rangle\) </p>

</div>
</div>
<a id="ac08e04314a805c456827f9b39c930180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08e04314a805c456827f9b39c930180">&#9670;&nbsp;</a></span>free_ipfb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_ipfb </td>
          <td>(</td>
          <td class="paramtype">struct gpu_ipfb_arrays *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the GPU memory allocated in <a class="el" href="pfb_8cpp.html#a6744a624a2063f1bce0e23ebf2880c24" title="Allocate GPU memory needed for performing the inverse PFB.">malloc_ipfb()</a>. </p>

</div>
</div>
<a id="ab30891f5325d182547a481d9143f490d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30891f5325d182547a481d9143f490d">&#9670;&nbsp;</a></span>gpuAssert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpuAssert </td>
          <td>(</td>
          <td class="paramtype">gpuError_t&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd399e8c525feba6355ab52ba02a9f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd399e8c525feba6355ab52ba02a9f1f">&#9670;&nbsp;</a></span>int2float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void int2float </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert 32-bit integers to 32-bit floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be converted </td></tr>
    <tr><td class="paramname">scale</td><td>A scaling factor to apply (set to 1 for no effect)</td></tr>
  </table>
  </dd>
</dl>
<p>Each thread handles a single integer, so the thread configuration can be chosen to suit the size of <code>data</code>.</p>
<p>This function acts as an alternative to <a class="el" href="pfb_8cpp.html#aa5d1c9b40a2932b8d4f48f76877207aa" title="CUDA kernel for performing the rounding and demotion step of the forward PFB.">fpga_rounding_and_demotion()</a>, in order to preserve the full precision of the PFB output. </p>

</div>
</div>
<a id="aa6eb2332a6371d8a576e6422d7bc9d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eb2332a6371d8a576e6422d7bc9d79">&#9670;&nbsp;</a></span>ipfb_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void ipfb_kernel </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>in_real</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>in_imag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ft_real</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ft_imag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUDA kernel implementing the synthesis PFB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_real</td><td>... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_imag</td><td>... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ft_real</td><td>... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ft_imag</td><td>... </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ntaps</td><td>... </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">npol</td><td>... </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>...</td></tr>
  </table>
  </dd>
</dl>
<p>The backwards/inverse/synthesis filter is </p><p class="formulaDsp">
\[ \hat{x}[n] = \frac{1}{K} \sum_m f[n - mM] \sum_{k=0}^{K-1} X_k[m]\,e^{2\pi jkn/K} \]
</p>
<p>The sum over <code>m</code> is nominally over all integers, but in practice only involves a few terms because of the finiteness of the filter, <code>f</code>. To be precise, there are precisely <code>ntaps</code> non-zero values.</p>
<p>\(X_k[m]\) represents the complex-valued inputs, <code>in_real</code> and <code>in_imag</code>. Every possible value of \(f[n]\,e^{2\pi jkn/K}\) is provided in <code>ft_real</code> and <code>ft_imag</code>.</p>
<p><code>K</code> is the number of channels, and because this is a critically sampled PFB, \(M = K\). We will also use <code>P</code> to mean the number of taps in the synthesis filter, and \(N = KP\) to mean the size of the filter.</p>
<p>The polarisations are computed completely independently.</p>
<p>\(\hat{x}[n]\) is represented by the <code>out</code> array.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>Revamp this function to use cuComplex. </dd></dl>

</div>
</div>
<a id="a6744a624a2063f1bce0e23ebf2880c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6744a624a2063f1bce0e23ebf2880c24">&#9670;&nbsp;</a></span>malloc_ipfb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void malloc_ipfb </td>
          <td>(</td>
          <td class="paramtype">struct gpu_ipfb_arrays *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pfb_filter *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npointing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate GPU memory needed for performing the inverse PFB. </p>
<p>Free with <a class="el" href="pfb_8cpp.html#ac08e04314a805c456827f9b39c930180" title="Free the GPU memory allocated in malloc_ipfb().">free_ipfb()</a>. </p>

</div>
</div>
<a id="a0a732480f8d3574b2916f75547ce1b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a732480f8d3574b2916f75547ce1b7b">&#9670;&nbsp;</a></span>pack_into_recombined_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void pack_into_recombined_format </td>
          <td>(</td>
          <td class="paramtype">gpuFloatComplex *&#160;</td>
          <td class="paramname"><em>ffted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pfb_flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUDA kernel for packing the PFB'ed data into legacy recombined layout/format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ffted</td><td>The already-FFT'ed PFB data, ready for packing </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outdata</td><td>The output data buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i_idx</td><td>An array of indexes for the desired ordering of the RF inputs (i.e. antenna/polarisation combinations) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>PFB configuration settings</td></tr>
  </table>
  </dd>
</dl>
<p>This is the final step in the forward fine PFB algorithm. At this point, the FFTED array contains the Fourier-transformed data that already represents the final channelisation. All that remains to be done is to pack it into the same layout (and optionally also the same format) as the VCS recombined data.</p>
<p>The relevant values for <code>flags</code> are (see <a class="el" href="pfb_8cpp.html#a9c933bc8f363e9480d75f32c6720fe56" title="Create and initialise a forward_pfb struct.">vmInitForwardPFB()</a> for the full table):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Flag name   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PFB_COMPLEX_INT4</code>   </td><td class="markdownTableBodyLeft">Typecast the output into (4+4)-bit complex integers    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PFB_COMPLEX_FLOAT64</code>   </td><td class="markdownTableBodyLeft">Typecast the output into (64+64)-bit complex floats   </td></tr>
</table>
<p>The expected thread configuration is \(\langle\langle\langle(\text{nspectra},K),I\rangle\rangle\rangle\). </p>

</div>
</div>
<a id="add07f7e3012c84b6d596b76d6ab1af82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add07f7e3012c84b6d596b76d6ab1af82">&#9670;&nbsp;</a></span>vmDownloadForwardPFBChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmDownloadForwardPFBChunk </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a chunk of PFB data from GPU to CPU. </p>
<p>A diagram of the memory layout of the copy operation: </p><div class="fragment"><div class="line">         &lt;--ds--&gt;</div>
<div class="line">Device: |--------|</div>
<div class="line">        ^ from</div>
<div class="line"> </div>
<div class="line">         &lt;--hs-&gt;</div>
<div class="line">Host:   |-------|-------|-------| ... |-------| ...</div>
<div class="line">chunk:  0       1       2       3     c</div>
<div class="line">                                      ^ to</div>
</div><!-- fragment --><p> where</p><ul>
<li><b>from</b> = <code>vm&rarr;fpfb&rarr;d_vcs_data</code></li>
<li><b>to</b> = <code>vm&rarr;fpfb&rarr;vcs_data + c*hs</code></li>
<li><b>ds</b> = <code>vm&rarr;fpfb&rarr;d_vcs_size</code></li>
<li><b>hs</b> = <code>vm&rarr;fpfb&rarr;vcs_stride</code></li>
<li><b>c</b> = <code>vm&rarr;chunk_to_load % vm&rarr;chunks_per_second</code></li>
</ul>
<p>Note that <b>ds</b> is not necessarily equal to <b>hs</b>, and that <b>ds</b> bytes are copied. </p>

</div>
</div>
<a id="a718c0996f48d674e941efd897aa9ae8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718c0996f48d674e941efd897aa9ae8f">&#9670;&nbsp;</a></span>vmExecuteForwardPFB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmExecuteForwardPFB </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The wrapper function that performs a forward PFB on the GPU. </p>
<p>For each chunk of data, it calls, in order,</p><ol type="1">
<li><a class="el" href="pfb_8cpp.html#afd8ef7871feb4b480442a73482cb4903" title="Copies a chunk of PFB data from CPU to GPU.">vmUploadForwardPFBChunk()</a></li>
<li><a class="el" href="pfb_8cpp.html#a353ec3d21419ab0192de2ea4771a77b3" title="Calls the vmWOLA_kernel() kernel for the forward PFB data.">vmWOLAChunk()</a></li>
<li><a class="el" href="pfb_8cpp.html#a51d546028e05c56e5bd4e53570054366" title="Calls the fpga_rounding_and_demotion() kernel for the forward PFB data.">vmFPGARoundingChunk()</a></li>
<li><a class="el" href="pfb_8cpp.html#a25d6f48661b1ee20194a9cdbb1370244" title="Executes the (CUDA) FFT on the forward PFB data.">vmFFTChunk()</a></li>
<li><a class="el" href="pfb_8cpp.html#aa6ff9eb0026fbdcf87817dbeb746fad6" title="Calls the pack_into_recombined_format() kernel for the forward PFB data.">vmPackChunk()</a></li>
</ol>
<p>If a buffer (<code>vm&rarr;fpfb&rarr;vcs_data</code>) has been prepared, then <a class="el" href="pfb_8cpp.html#add07f7e3012c84b6d596b76d6ab1af82" title="Copies a chunk of PFB data from GPU to CPU.">vmDownloadForwardPFBChunk()</a> is called. </p>

</div>
</div>
<a id="a25d6f48661b1ee20194a9cdbb1370244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d6f48661b1ee20194a9cdbb1370244">&#9670;&nbsp;</a></span>vmFFTChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFFTChunk </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the (CUDA) FFT on the forward PFB data. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>Keep this as a "pure" forward_pfb function, and make a separate "vm" function that's exposed. </dd></dl>

</div>
</div>
<a id="a51d546028e05c56e5bd4e53570054366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d546028e05c56e5bd4e53570054366">&#9670;&nbsp;</a></span>vmFPGARoundingChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFPGARoundingChunk </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the <a class="el" href="pfb_8cpp.html#aa5d1c9b40a2932b8d4f48f76877207aa" title="CUDA kernel for performing the rounding and demotion step of the forward PFB.">fpga_rounding_and_demotion()</a> kernel for the forward PFB data. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd>Keep this as a "pure" forward_pfb function, and make a separate "vm" function that's exposed. </dd></dl>

</div>
</div>
<a id="a54059e7d31bcf4eccc39609e72ad8189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54059e7d31bcf4eccc39609e72ad8189">&#9670;&nbsp;</a></span>vmFreeForwardPFB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmFreeForwardPFB </td>
          <td>(</td>
          <td class="paramtype">forward_pfb *&#160;</td>
          <td class="paramname"><em>fpfb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees host and device memory allocated in <a class="el" href="pfb_8cpp.html#a9c933bc8f363e9480d75f32c6720fe56" title="Create and initialise a forward_pfb struct.">vmInitForwardPFB()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpfb</td><td>The <code>forward_pfb</code> object to be freed.</td></tr>
  </table>
  </dd>
</dl>
<p>After freeing the member variables of <code>fpfb</code>, the struct itself is freed. </p>

</div>
</div>
<a id="a9c933bc8f363e9480d75f32c6720fe56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c933bc8f363e9480d75f32c6720fe56">&#9670;&nbsp;</a></span>vmInitForwardPFB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmInitForwardPFB </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pfb_flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialise a forward_pfb struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>The VCSBeam context struct </td></tr>
    <tr><td class="paramname">M</td><td>The "stride" of the PFB </td></tr>
    <tr><td class="paramname">flags</td><td>PFB configuration settings</td></tr>
  </table>
  </dd>
</dl>
<p>Setting \(M = K\), where \(K\) is the value of <code>vm&rarr;analysis_filter&rarr;nchans</code>, will make this a "critically sampled PFB"; setting \(M &gt; K\), an "oversampled PFB".</p>
<p>A filter must already be loaded into <code>vm&rarr;analysis_filter</code>. <b>WARNING! The filter will be forcibly typecast to int!!</b></p>
<p>The GPU processing will be divided up into <code>vm&rarr;chunks_per_second</code>, chunks per second, but if this number does not divide the number of samples (10000) evenly, then it is incremented until it does.</p>
<p>The available flags are given in the following table: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Flag name   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PFB_MALLOC_HOST_INPUT</code>   </td><td class="markdownTableBodyLeft">Allocate memory on CPU for the input    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PFB_MALLOC_HOST_OUTPUT</code>   </td><td class="markdownTableBodyLeft">Allocate memory on CPU for the output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PFB_MALLOC_DEVICE_INPUT</code>   </td><td class="markdownTableBodyLeft">Allocate memory on GPU for the input    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PFB_MALLOC_DEVICE_OUTPUT</code>   </td><td class="markdownTableBodyLeft">Allocate memory on GPU for the output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PFB_MALLOC_ALL</code>   </td><td class="markdownTableBodyLeft">Synonym for <code>PFB_MALLOC_HOST_INPUT | PFB_MALLOC_HOST_OUTPUT | PFB_MALLOC_DEVICE_INPUT | PFB_MALLOC_DEVICE_OUTPUT</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PFB_COMPLEX_INT4</code>   </td><td class="markdownTableBodyLeft">Typecast the output into (4+4)-bit complex integers    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PFB_COMPLEX_FLOAT64</code>   </td><td class="markdownTableBodyLeft">Typecast the output into (64+64)-bit complex floats    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PFB_IMAG_PART_FIRST</code>   </td><td class="markdownTableBodyLeft">Place the imaginary part of the output in the first (i.e. most significant) position    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PFB_EMULATE_FPGA</code>   </td><td class="markdownTableBodyLeft">Perform the (asymmetric) rounding and demotion step in exactly the same way as the original (Phase 1 &amp; 2) MWA FPGAs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>PFB_SMART</code>   </td><td class="markdownTableBodyLeft">Synonym for <code>PFB_MALLOC_HOST_INPUT | PFB_MALLOC_DEVICE_INPUT | PFB_MALLOC_DEVICE_OUTPUT | PFB_EMULATE_FPGA | PFB_COMPLEX_INT4</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>PFB_FULL_PRECISION</code>   </td><td class="markdownTableBodyLeft">Synonym for <code>PFB_MALLOC_HOST_INPUT | PFB_MALLOC_DEVICE_INPUT | PFB_MALLOC_DEVICE_OUTPUT | PFB_COMPLEX_FLOAT64</code>   </td></tr>
</table>

</div>
</div>
<a id="aa6ff9eb0026fbdcf87817dbeb746fad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ff9eb0026fbdcf87817dbeb746fad6">&#9670;&nbsp;</a></span>vmPackChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmPackChunk </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the <a class="el" href="pfb_8cpp.html#a0a732480f8d3574b2916f75547ce1b7b" title="CUDA kernel for packing the PFB&#39;ed data into legacy recombined layout/format.">pack_into_recombined_format()</a> kernel for the forward PFB data. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>Keep this as a "pure" forward_pfb function, and make a separate "vm" function that's exposed. </dd></dl>

</div>
</div>
<a id="afd8ef7871feb4b480442a73482cb4903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8ef7871feb4b480442a73482cb4903">&#9670;&nbsp;</a></span>vmUploadForwardPFBChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmUploadForwardPFBChunk </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a chunk of PFB data from CPU to GPU. </p>
<p>A diagram of the memory layout of the copy operation: </p><div class="fragment"><div class="line">         &lt;--hs-&gt;</div>
<div class="line">Host:   |-------|-------|-------| ... |-------| ...</div>
<div class="line">chunk:  0       1       2       3     c</div>
<div class="line">                                      ^ from</div>
<div class="line"> </div>
<div class="line">         &lt;--ds--&gt;</div>
<div class="line">Device: |--------|</div>
<div class="line">        ^ to</div>
</div><!-- fragment --><p> where</p><ul>
<li><b>from</b> = <code>vm&rarr;v&rarr;buffer + c*hs</code></li>
<li><b>to</b> = <code>vm&rarr;fpfb&rarr;d_htr_data</code></li>
<li><b>ds</b> = <code>vm&rarr;fpfb&rarr;d_htr_size</code></li>
<li><b>hs</b> = <code>vm&rarr;fpfb&rarr;htr_stride</code></li>
<li><b>c</b> = <code>vm&rarr;chunk_to_load % vm&rarr;chunks_per_second</code></li>
</ul>
<p>Note that <b>ds</b> is not necessarily equal to <b>hs</b>, and that <b>ds</b> bytes are copied. </p>

</div>
</div>
<a id="a7374f0e61cc4b19318b0aca79c8f40df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7374f0e61cc4b19318b0aca79c8f40df">&#9670;&nbsp;</a></span>vmWOLA_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vmWOLA_kernel </td>
          <td>(</td>
          <td class="paramtype">char2 *&#160;</td>
          <td class="paramname"><em>indata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>filter_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>weighted_overlap_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the weighted overlap-add part of the PFB algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indata</td><td>The input data, \(x[n]\), with layout equivalent to the buffer populated by mwalib (see [the MWAX voltage format][MWAXHTR]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_coeffs</td><td>The PFB filter coefficients, \(h[n]\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">weighted_overlap_array</td><td>The result of the weighted overlap-add operation, \(b[n]\)</td></tr>
  </table>
  </dd>
</dl>
<p>The weighted overlap-add part of the PFB algorithm is the equation </p><p class="formulaDsp">
\[ b_m[n] = \sum_\rho^{P-1} h[K\rho - n] x[n + mM - K\rho]. \]
</p>
<p> See above for the meaning of the terms in this equation.</p>
<p>The expected thread configuration is \( \langle\langle\langle (\text{nspectra},I,P), K \rangle\rangle\rangle \)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>Add data layout information to this docstring. </dd></dl>

</div>
</div>
<a id="a353ec3d21419ab0192de2ea4771a77b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353ec3d21419ab0192de2ea4771a77b3">&#9670;&nbsp;</a></span>vmWOLAChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmWOLAChunk </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the <a class="el" href="pfb_8cpp.html#a7374f0e61cc4b19318b0aca79c8f40df" title="Performs the weighted overlap-add part of the PFB algorithm.">vmWOLA_kernel()</a> kernel for the forward PFB data. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>Keep this as a "pure" forward_pfb function, and make a separate "vm" function that's exposed. </dd></dl>

</div>
</div>
<a id="a831bf4d5d1a25ca5d2deeb0def57cd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831bf4d5d1a25ca5d2deeb0def57cd2a">&#9670;&nbsp;</a></span>vmWritePFBOutputToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmWritePFBOutputToFile </td>
          <td>(</td>
          <td class="paramtype">vcsbeam_context *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the result of the forward PFB operation to file. </p>
<p>This function writes the contents of <code>vm&rarr;fpfb&rarr;vcs_data</code> to a file whose name is returned by the function <a class="el" href="metadata_8c.html#a229dbe21a869afa361c5adb778b6b580" title="Gets the file name for the given channel index and GPS, as if the observation were a Legacy VCS obser...">vmGetLegacyVoltFilename()</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
